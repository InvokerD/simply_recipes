# تمرین اصول شی‌گرایی — سیستم رزرو هتل

این پروژه بر اساس کد پایه از [base-project-for-solid](https://github.com/yahyaPoursoltani/base-project-for-solid) انجام شده و شامل دو خروجی اصلی است: **OOD-without-01-Step** (گام اول) و **OOD-with-02-Step** (گام سوم پس از اصالح).

---

## گام اول — افزودن دو قابلیت جدید (OOD-without-01-Step)

در این گام دو قابلیت زیر به برنامه اولیه اضافه شد **بدون** رعایت اصول شی‌گرایی:

1. **روش ارسال پیامک** — مشابه EmailSender
2. **روش پرداخت حضوری (On-Site)** — در PaymentProcessor

### جدول تغییرات گام اول

| ردیف | تغییرات مربوط به افزودن روش جدید ارسال پیام | تغییرات مربوط به افزودن روش جدید پرداخت |
|------|---------------------------------------------|-----------------------------------------|
| **کلاس تغییر یافته** | **توضیح کوتاه** | **کلاس تغییر یافته** | **توضیح کوتاه** |
| 1 | `SmsSender` (کلاس جدید) | افزودن کلاس جدید با متد `sendSmsMessage` برای ارسال پیامک | `PaymentProcessor` | افزودن متد `payByOnSite` برای پرداخت حضوری |
| 2 | `ReservationService` | افزودن `case SMS` در switch اعلان‌رسانی و فراخوانی `SmsSender.sendSmsMessage` | `ReservationService` | افزودن `case ONSITE` در switch پرداخت و فراخوانی `paymentProcessor.payByOnSite` |
| 3 | `ReservationService` | تغییر از `this.notifier` به پارامتر `notifier` در switch تا نوع اعلان از Main قابل انتخاب باشد | `constants.PaymentMethods` | در صورت نبود، افزودن مقدار `ONSITE` به enum |
| 4 | `constants.Notifier` | در صورت نبود، افزودن مقدار `SMS` به enum | — | — |

---

## گام دوم — تحلیل اصول شی‌گرایی (کد اولیه)

بر اساس کد اولیه و تجربه گام ۱، وضعیت اصول زیر بررسی شده است.

| اصل | وضعیت | کلاس/بخش | علت |
|-----|--------|-----------|-----|
| **SRP** (Single Responsibility) | نقض | `ReservationService` | یک کلاس هم تخفیف شهر، هم پرداخت، هم چاپ فاکتور و هم ارسال اعلان را انجام می‌دهد؛ چند مسئولیت در یک کلاس. |
| **OCP** (Open/Closed) | نقض | `ReservationService` | برای افزودن روش پرداخت یا اعلان جدید باید switchها را تغییر داد و کد موجود را باز کرد. |
| **LSP** (Liskov Substitution) | برقراری | `Room` / `LuxuryRoom` | زیرکلاس LuxuryRoom قابل جایگزینی با Room است. |
| **LSP** | نقض (احتمالی) | `MessageSender` | رابط فقط `sendEmail` دارد؛ SmsSender مجبور است این متد را implement کند در حالی که معنای آن برای SMS متفاوت است (نام متد با رفتار سازگار نیست). |
| **ISP** (Interface Segregation) | نقض | `MessageSender` | رابط برای ارسال ایمیل طراحی شده؛ برای SMS مجبور به استفاده از همان امضای sendEmail یا افزودن متد جدید در همان رابط می‌شویم. |
| **DIP** (Dependency Inversion) | نقض | `ReservationService` | وابستگی مستقیم به کلاس‌های concrete مانند `EmailSender` و `PaymentProcessor`؛ باید به انتزاع (interface) وابسته باشد. |
| **PLK** (Principle of Least Knowledge) | نقض | `ReservationService` | وابستگی به جزئیات داخلی (مثلاً نوع پرداخت و نوع اعلان) و ساخت مستقیم اشیاء سرویس. |
| **CRP** (Composite Reuse) | نقض / ضعف | طراحی کلی | ترجیح ارث‌بری و switch بر ترکیب و پلی‌مورفیسم؛ قابلیت استفاده مجدد از ترکیب کمتر است. |

---

## گام سوم — اصالح موارد نقض (OOD-with-02-Step)

در پوشه **OOD-with-02-Step** اصالحات زیر برای رعایت اصول شی‌گرایی انجام شده است:

1. **DIP و OCP**  
   - تعریف رابط‌های `PaymentMethod` و `ReservationNotifier`.  
   - `ReservationService` فقط به این رابط‌ها وابسته است و دیگر به کلاس‌های concrete وابسته نیست.  
   - افزودن روش پرداخت یا اعلان جدید با اضافه کردن کلاس جدید و در صورت نیاز یک case در Factory انجام می‌شود؛ منطق اصلی سرویس تغییر نمی‌کند.

2. **SRP**  
   - منطق پرداخت به کلاس‌های implementکننده `PaymentMethod` و منطق اعلان به کلاس‌های implementکننده `ReservationNotifier` منتقل شده است.  
   - `ReservationService` فقط هماهنگی رزرو، اعمال تخفیف (در حد ساده)، چاپ فاکتور و فراخوانی پرداخت و اعلان را انجام می‌دهد.

3. **LSP و ISP**  
   - رابط `ReservationNotifier` با متد `sendConfirmation(Reservation, String)` تعریف شده و برای هر نوع اعلان (ایمیل، SMS) یک implement جداگانه وجود دارد؛ دیگر نیازی به متد `sendEmail` در رابط اعلان نیست.

4. **افزودن قابلیت‌ها در طراحی اصالح‌شده**  
   - **SMS:** کلاس `SmsNotifier` و در صورت نیاز مقدار `SMS` در enum و در Factory.  
   - **پرداخت حضوری:** کلاس `OnSitePayment` و در صورت نیاز مقدار `ONSITE` در enum و در `PaymentMethodFactory`.

---

## گام چهارم — ارزیابی

- **اگر از ابتدا اصول شی‌گرایی رعایت می‌شد:**  
  بسیاری از تغییرات داخل `ReservationService` (افزودن caseهای جدید در switchها) لازم نبود.  
  فقط با **افزودن کلاس‌های جدید** (`SmsSender`/`SmsNotifier` و یک کلاس پرداخت حضوری) و در صورت استفاده از enum/Factory، **یک case در Factory** برای هر قابلیت کافی بود.

- **تعداد تغییرات حذف‌شده در گام اول:**  
  تغییرات در خود `ReservationService` (دو switch و چند خط مرتبط) حذف می‌شدند؛ یعنی حدود **۲ تا ۴ تغییر** در یک کلاس حذف می‌شد.

- **تعداد تغییرات برای افزودن دو قابلیت در طراحی اصالح‌شده:**  
  - برای **SMS:** یک کلاس جدید (`SmsNotifier`) + یک case در `NotifierFactory` (و در صورت نیاز یک مقدار در enum).  
  - برای **پرداخت حضوری:** یک کلاس جدید (`OnSitePayment`) + یک case در `PaymentMethodFactory` (و در صورت نیاز یک مقدار در enum).  
  یعنی **۲ کلاس جدید + ۲ case در Factoryها** و بدون تغییر در `ReservationService`.

---

## گام پنجم — نتیجه‌گیری

رعایت اصول شی‌گرایی در این برنامه به شکل زیر به **قابلیت نگهداری و توسعه** کمک می‌کند:

- **کمتر شدن تغییر در کد موجود:** با وابستگی به رابط‌ها (DIP) و باز بودن برای گسترش بدون تغییر منطق اصلی (OCP)، برای اضافه کردن روش پرداخت یا اعلان جدید، فقط کلاس و در صورت نیاز یک مورد در Factory اضافه می‌شود و نیازی به باز کردن و تغییر `ReservationService` نیست.
- **کاهش خطا و اثر جانبی:** با تفکیک مسئولیت (SRP)، تغییر در یک بخش (مثلاً نحوه پرداخت) کمتر روی بخش‌های دیگر اثر می‌گذارد.
- **تست‌پذیری بهتر:** با تزریق وابستگی و استفاده از interface، می‌توان در تست از mock استفاده کرد.
- **خوانایی و نگهداری:** رابط‌های کوچک و مشخص (ISP) و استفاده از ترکیب و پلی‌مورفیسم (CRP) باعث می‌شود ساختار برنامه قابل فهم‌تر و قابل توسعه‌تر باشد.

---

## ساختار تحویل

- **OOD-without-01-Step:** خروجی گام اول (افزودن دو قابلیت بدون اصالح اصول).
- **OOD-with-02-Step:** خروجی گام سوم (اصالح نقض‌ها + همان دو قابلیت با رعایت اصول).
- **README.md:** گزارش گام‌های ۱ تا ۵ (همین فایل).

---

## نحوه اجرا

- در هر دو پوشه، فایل‌های Java در `src` قرار دارند.  
- با javac یا از طریق IDE می‌توانید پروژه را کامپایل و اجرا کنید؛ نقطه ورود `Main.java` است.

```bash
# مثال (در صورت نصب JDK):
cd OOD-without-01-Step
javac -d out src/constants/*.java src/models/*.java src/services/*.java src/Main.java
java -cp out Main

cd ../OOD-with-02-Step
javac -d out src/constants/*.java src/models/*.java src/services/*.java src/Main.java
java -cp out Main
```
